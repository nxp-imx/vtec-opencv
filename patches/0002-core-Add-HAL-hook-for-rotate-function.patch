From 20b581619c0295b46295885e490ccb33bad25bfa Mon Sep 17 00:00:00 2001
From: Julien Vuillaumier <julien.vuillaumier@nxp.com>
Date: Wed, 26 Jul 2023 10:23:28 +0200
Subject: [PATCH 2/2] core: Add HAL hook for rotate() function

This change is adding a HAL hook for custom cv::rotate()
implementation.

Rotate operation is currently implemented as a composition of
cv::transpose() and cv::flip(), which makes some operations
a 2-steps process.

2D accelerators are usually capable of applying rotation in a
single step. Therefore, HAL function is hooked in the cv::rotate()
function rather than in the cv::transpose() and cv::flip() ones.

Prototype of the HAL override function is:

/**
   @brief rotate
   @param src_type source and destination image type
   @param src_data source image data
   @param src_step source image step
   @param src_width source image width
   If angle has value [180] it is also destination image width
   If angle has values [90, 270] it is also destination image height
   @param src_height source and destination image height (destination image width for angles [90, 270])
   If angle has value [180] it is also destination image height
   If angle has values [90, 270] it is also destination image width
   @param dst_data destination image data
   @param dst_step destination image step
   @param angle clockwise angle for rotation in degrees from set [90, 180, 270]
*/

void rotate( int src_type, const uchar* src_data, size_t src_step,
             int src_width, int src_height,
             uchar* dst_data, size_t dst_step,
             int angle);
---
 modules/core/include/opencv2/core/hal/hal.hpp |  1 +
 modules/core/src/hal_replacement.hpp          | 23 +++++++++
 modules/core/src/matrix_transform.cpp         | 48 ++++++++++++++++++-
 3 files changed, 71 insertions(+), 1 deletion(-)

diff --git a/modules/core/include/opencv2/core/hal/hal.hpp b/modules/core/include/opencv2/core/hal/hal.hpp
index b7e96d770a..68b095aad0 100644
--- a/modules/core/include/opencv2/core/hal/hal.hpp
+++ b/modules/core/include/opencv2/core/hal/hal.hpp
@@ -202,6 +202,7 @@ CV_EXPORTS void addRNGBias32f( float* arr, const float* scaleBiasPairs, int len
 CV_EXPORTS void addRNGBias64f( double* arr, const double* scaleBiasPairs, int len );
 
 CV_EXPORTS void flip( int src_type, const uchar* src_data, size_t src_step, int src_width, int src_height, uchar* dst_data, size_t dst_step, int flip_mode );
+CV_EXPORTS void rotate( int src_type, const uchar* src_data, size_t src_step, int src_width, int src_height, uchar* dst_data, size_t dst_step, int angle );
 
 struct CV_EXPORTS DFT1D
 {
diff --git a/modules/core/src/hal_replacement.hpp b/modules/core/src/hal_replacement.hpp
index 8ed0e56661..7efc445ee9 100644
--- a/modules/core/src/hal_replacement.hpp
+++ b/modules/core/src/hal_replacement.hpp
@@ -749,6 +749,29 @@ inline int hal_ni_flip(int src_type, const uchar* src_data, size_t src_step, int
 #define cv_hal_flip hal_ni_flip
 //! @endcond
 
+
+/**
+   @brief rotate
+   @param src_type source and destination image type
+   @param src_data source image data
+   @param src_step source image step
+   @param src_width source image width
+   If angle has value [180] it is also destination image width
+   If angle has values [90, 270] it is also destination image height
+   @param src_height source and destination image height (destination image width for angles [90, 270])
+   If angle has value [180] it is also destination image height
+   If angle has values [90, 270] it is also destination image width
+   @param dst_data destination image data
+   @param dst_step destination image step
+   @param angle clockwise angle for rotation in degrees from set [90, 180, 270]
+ */
+inline int hal_ni_rotate(int src_type, const uchar* src_data, size_t src_step, int src_width, int src_height,
+                         uchar* dst_data, size_t dst_step, int angle) { return CV_HAL_ERROR_NOT_IMPLEMENTED; }
+
+//! @cond IGNORED
+#define cv_hal_rotate hal_ni_rotate
+//! @endcond
+
 //! @}
 
 
diff --git a/modules/core/src/matrix_transform.cpp b/modules/core/src/matrix_transform.cpp
index d0e11c6adb..97444e8216 100644
--- a/modules/core/src/matrix_transform.cpp
+++ b/modules/core/src/matrix_transform.cpp
@@ -861,7 +861,7 @@ void flipND(InputArray _src, OutputArray _dst, int _axis)
     flipNDImpl(dst.ptr(), dst.size.p, dst.step.p, axis);
 }
 
-void rotate(InputArray _src, OutputArray _dst, int rotateMode)
+static void rotateImpl(InputArray _src, OutputArray _dst, int rotateMode)
 {
     CV_Assert(_src.dims() <= 2);
 
@@ -883,4 +883,50 @@ void rotate(InputArray _src, OutputArray _dst, int rotateMode)
     }
 }
 
+void rotate(InputArray _src, OutputArray _dst, int rotateMode)
+{
+    int angle;
+
+    if (_dst.isUMat())
+    {
+        rotateImpl(_src, _dst, rotateMode);
+        return;
+    }
+
+    Mat src = _src.getMat();
+    int type = src.type();
+    if( src.empty() )
+    {
+        _dst.release();
+        return;
+    }
+
+    switch (rotateMode)
+    {
+    case ROTATE_90_CLOCKWISE:
+        _dst.create(src.cols, src.rows, type);
+        angle = 90;
+        break;
+    case ROTATE_180:
+        _dst.create(src.rows, src.cols, type);
+        angle = 180;
+        break;
+    case ROTATE_90_COUNTERCLOCKWISE:
+        _dst.create(src.cols, src.rows, type);
+        angle = 270;
+        break;
+    default:
+        _dst.create(src.rows, src.cols, type);
+        angle = 0;
+        break;
+    }
+
+    Mat dst = _dst.getMat();
+    CALL_HAL(rotate, cv_hal_rotate, type, src.ptr(), src.step, src.cols, src.rows,
+             dst.ptr(), dst.step, angle);
+
+    // use src (Mat) since _src (InputArray) is updated by _dst.create() when in-place
+    rotateImpl(src, _dst, rotateMode);
+}
+
 }  // namespace
-- 
2.25.1

